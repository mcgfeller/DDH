""" Fixtures for testing with actual microservices """


import httpx
import pytest
import pcp
import time
import logging

from core import storage_resource, errors

logger = logging.getLogger('service')


@pytest.fixture(scope="session")
def httpx_processes(wait: float = 3):
    """ Start the uvicorn server with the FastAPI app on PORT;
        Finalizer terminated started server.
    """
    processes = start_servers(wait=wait)
    yield processes
    # Finalizer:
    processes.stop(pcp.getargs())
    return


@pytest.fixture(scope="session")
def user1(httpx_processes):
    client = get_authorized_client(httpx_processes, 'api', {'username': 'mgf', 'password': 'secret'})
    yield client
    # Finalizer:
    client.close()
    return


@pytest.fixture(scope="session")
def user1_sub(httpx_processes):
    client = get_authorized_client(httpx_processes, 'subscription', {'username': 'mgf', 'password': 'secret'})
    yield client
    # Finalizer:
    client.close()
    return


@pytest.fixture(scope="session")
def user1_market(httpx_processes):
    client = get_authorized_client(httpx_processes, 'market', {'username': 'mgf', 'password': 'secret'})
    yield client
    # Finalizer:
    client.close()
    return


def _analyze_response(resp: httpx.Response):
    """ httpx event hook to log response if not OK. 
        JSON generated by Pydantic / FastAPI has a 'detail' message. 
        Works only for synch clients. 
    """
    if resp.is_error:
        _ = resp.read()  # read stream
        if 'json' in resp.headers.get('content-type', ''):
            j = resp.json()
            for k in ('message', 'detail', 'error',):
                d = j.get(k, None)
                if d:
                    logger.error(f'http {resp.status_code} returned {k}: {d}')
        else:
            t = resp.text
            logger.error(f'http {resp.status_code} returned text: {t}')
    return


def get_authorized_client(processes, procid, userpwd, tokenserver: str | None = None, add_headers: dict = {}) -> httpx.Client:
    """ return a client with header configured for userpwd """
    port = processes.get(procid)[0].port  # get the API server
    tokenurl = url = 'http://localhost:'+str(port)
    if tokenserver and tokenserver != procid:
        tokenport = processes.get(tokenserver)[0].port  # get the token API server
        tokenurl = 'http://localhost:'+str(tokenport)  # get the API server

    r = httpx.post(tokenurl+'/token', data=userpwd)  # obtain token
    r.raise_for_status()
    token = r.json()['access_token']
    headers = httpx.Headers({'Authorization': 'Bearer '+token, 'x-user': userpwd['username']})
    headers.update(add_headers)
    # client with token in header, large timeout for debugging

    client = httpx.Client(base_url=url, headers=headers, timeout=60, event_hooks={'response': [_analyze_response]})
    return client


def start_servers(wait: float = 3):
    """ Start all DDH servers, including DApps """
    pcp.ddh.start(pcp.getargs())
    time.sleep(wait)  # give a bit time to start
    # Check that no process has crashed:
    a = pcp.getargs()
    a.raise_error = True  # check processes and raise if one isn't running
    pcp.ddh.check(a)
    return pcp.ddh


@classmethod
def create_no_storage_dapp(cls, id):
    """ create DAppResource from Id, replace by InProcessStorageResource if there is
        an error because DApp is not running.
    """
    try:
        return cls.__bases__[0].create(id)  # cannot use super() in monkey patched classmethod
    except errors.NotSelectable:
        return storage_resource.InProcessStorageResource(dapp=None)


@pytest.fixture
def no_storage_dapp(monkeypatch):
    monkeypatch.setattr(storage_resource.StorageResource, 'create', create_no_storage_dapp)
